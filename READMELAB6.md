# Жадный алгоритм для выбора задач (Task Selection)
Задача: реализовать жадный алгоритм для выбора максимального количества
непересекающихся задач (интервалов).
Требования:
- Каждая задача имеет время начала и завершения
- Выбрать максимальное количество задач, не пересекающихся по времени
- Вывести выбранные задачи и их количество
Входные данные:
Задачи: {(1,3), (2,5), (4,6), (5,8), (7,9), (8,10)}

Определение:

Жадный алгоритм - это алгоритмическая парадигма, которая принимает локально оптимальное решение на каждом шаге в надежде найти глобально оптимальное решение всей задачи.

Принцип работы жадного алгоритма для непересекающихся интервалов:

- Исходный список задач сортируется по времени завершения (второй элемент кортежа)
- Создается пустой список для выбранных задач и переменная для отслеживания времени окончания последней выбранной задачи
- Для каждой задачи в отсортированном списке проверяется условие непересечения: время начала текущей задачи должно быть больше или равно времени окончания последней выбранной задачи
- Если условие выполняется, задача добавляется в список выбранных и обновляется время окончания последней выбранной задачи
- Процесс продолжается до обработки всех задач в отсортированном списке
- Результатом является список непересекающихся задач максимальной длины

Использованные операторы и функции:

- len(tasks) - получение количества задач в списке
- sorted(tasks, key=lambda x: x[1]) - сортировка списка задач по второму элементу кортежа (времени завершения)
- lambda x: x[1] - анонимная функция для доступа к второму элементу кортежа
- for task in sorted_tasks: - цикл по элементам отсортированного списка
- start, end = task - распаковка кортежа на переменные
- start >= last_end_time - сравнение времени начала текущей задачи с временем окончания последней выбранной
- selected_tasks.append(task) - добавление элемента в конец списка
- last_end_time = end - присваивание нового значения переменной
- return selected_tasks, len(selected_tasks) - возврат кортежа с результатами
- str.strip() - удаление пробелов в начале и конце строки
- str.split(',') - разделение строки по запятым
- str.split() - разделение строки по пробелам
- int(numbers[0]) - преобразование строки в целое число
- start < end - проверка корректности интервала
- start >= 0 and end >= 0 - проверка неотрицательности временных меток
- tasks.append((start, end)) - добавление кортежа в список
- if not user_input: - проверка пустой строки
- if not tasks: - проверка пустого списка задач
- for pair in pairs: - цикл по элементам списка пар
- for task in selected_tasks: - цикл по выбранным задачам для вывода

Временная сложность:

Общая временная сложность: O(n log n). Почему? Потому что встроенная функция sorted() в Python использует алгоритм Timsort.

# Контрольные вопросы № 10.

Эвристические алгоритмы
Чем эвристические алгоритмы отличаются от приближенных? Приведите примеры.

Ответ:
Различия эвристических и приближенных алгоритмов

-Эвристические алгоритмы не дают гарантий качества решения и работают на основе практических правил. Они часто быстрые, но их погрешность неизвестна и непредсказуема.

-Приближенные алгоритмы обеспечивают доказанные границы погрешности и работают за полиномиальное время. Они надежны и предсказуемы, но могут быть медленнее эвристик.

Итог: Эвристики используют там, где важна скорость, а приближенные алгоритмы — где нужны гарантии качества.

Пример:
Задача: Расписание выполнения задач на одном процессоре

# Эвристический алгоритм:

//Правило: Сначала самые короткие задачи
tasks.sort(key=lambda x: x.duration)

# Приближенный алгоритм:

//Алгоритм с гарантией 4/3-приближения
if есть_длинные_задачи:
    использовать_специальное_расписание
else:
    использовать_жадное_расписание


