# Контрольное задание 15(вариант 15)

Жадный алгоритм: упаковка в контейнеры
Условие. Даны предметы с весами wi и контейнеры вместимостью W. Упаковать все 
предметы в минимальное число контейнеров (жадно).
Алгоритм: первый подходящий (First‑Fit).
Язык примера: Java
``` public static int firstFit(int[] weights, int W) {
 List<Integer> bins = new ArrayList<>(); // текущие загрузки контейнеров
 for (int w : weights) {
   boolean packed = false;
   for (int i = 0; i < bins.size(); i++) {
     if (bins.get(i) + w <= W) {
       bins.set(i, bins.get(i) + w);
       packed = true;
       break;
     }
   }
   if (!packed) {
       // ДОПИСАТЬ: добавить новый контейнер с весом w
   }
 }
 return bins.size();
}
```
Что дописать: добавление нового элемента в bins.

# Жадный алгоритм для упаковки в контейнеры (First-Fit)

**Задача:** реализовать жадный алгоритм для упаковки предметов в минимальное количество контейнеров. Требования:

- Каждый предмет имеет вес wi
- Каждый контейнер имеет вместимость W
- Упаковать все предметы в минимальное число контейнеров
- Вывести количество использованных контейнеров

## Определение:

**Жадный алгоритм First-Fit** - это алгоритмическая парадигма, которая на каждом шаге помещает предмет в первый подходящий контейнер, принимая локально оптимальное решение в надежде найти глобально оптимальное решение всей задачи.

## Принцип работы жадного алгоритма First-Fit для упаковки в контейнеры:

1. **Создается пустой список для отслеживания текущей загрузки контейнеров**
   ```java
   List<Integer> bins = new ArrayList<>(); // текущие загрузки контейнеров
   ```

2. **Для каждого предмета в исходном списке проверяются все существующие контейнеры**
   ```java
   for (int w : weights) {
       boolean packed = false;
       for (int i = 0; i < bins.size(); i++) {
   ```

3. **Если предмет помещается в текущий контейнер (сумма веса контейнера и предмета ≤ W), предмет добавляется в этот контейнер**
   ```java
   if (bins.get(i) + w <= W) {
       bins.set(i, bins.get(i) + w);
       packed = true;
       break;
   }
   ```

4. **Если предмет не помещается ни в один существующий контейнер, создается новый контейнер**
   ```java
   if (!packed) {
       bins.add(w); // добавить новый контейнер с весом w
   }
   ```
   
5. **Результатом является минимальное количество контейнеров, необходимых для упаковки всех предметов**
   ```java
   return bins.size();
   ```

## Использованные операторы и функции:

- `List<Integer> bins = new ArrayList<>()` - создание списка для хранения загрузки контейнеров
- `for (int w : weights)` - цикл for-each по всем предметам
- `bins.size()` - получение количества текущих контейнеров
- `bins.get(i)` - доступ к загрузке i-го контейнера
- `bins.get(i) + w <= W` - проверка условия помещения предмета в контейнер
- `bins.set(i, bins.get(i) + w)` - обновление загрузки контейнера
- `bins.add(w)` - создание нового контейнера с предметом
- `return bins.size()` - возврат количества использованных контейнеров
- `Scanner scanner = new Scanner(System.in)` - создание объекта для ввода данных
- `scanner.nextInt()` - чтение целого числа из консоли
- `scanner.close()` - закрытие сканера
- `System.out.print()` и `System.out.println()` - вывод данных в консоль

## Временная сложность:

**Общая временная сложность:** O(n²), где n - количество предметов. Потому что для каждого из n предметов в худшем случае мы проверяем все существующие контейнеры (которых может быть до n).

# Контрольные вопросы задание 15

**15. Локальный поиск**
Что такое локальный оптимум и почему метаэвристики нужны для его преодоления?

**Локальный оптимум** — это лучшее решение в своей небольшой, ограниченной "окрестности" пространства решений, но не обязательно лучшее решение для всей задачи в целом.

**Метаэвристики** — это продвинутые алгоритмы поиска, которые жертвуют гарантией нахождения идеального решения ради возможности найти очень хорошее решение за разумное время в сложных задачах.

Они нужны для преодоления локальных оптимумов, потому что используют специальные механизмы, позволяющие "прыгать" из зоны притяжения одного оптимума в другую. В отличие от простых алгоритмов, они иногда допускают **временное ухудшение решения**, чтобы исследовать новые, потенциально более перспективные области.
