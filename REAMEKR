1) БЛОЧНАЯ СОРТИРОВКА (BUCKET SORT) 

Блочная сортировка (bucket sort) — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости 
от диапазона их значений. После этого каждая корзина сортируется отдельно (либо тем же методомрекурсивно, либо другим алгоритмом, например,
вставками), и отсортированные корзины объединяются обратно в один массив.

Принцип работы:

-Создается num_buckets пустых корзин (обычно равно количеству элементов)
-Для каждого элемента вычисляется индекс корзины: bucket_index = int(num * num_buckets)
-Элементы добавляются в соответствующие корзины
-Каждая непустая корзина сортируется отдельно (встроенной сортировкой)
-Отсортированные корзины объединяются в результирующий массив

Использованные операторы и функции:

-len(arr) - получение длины массива
-range(num_buckets) - создание диапазона для цикла
-[[] for _ in range(num_buckets)] - списковое включение для создания пустых корзин
-for num in arr: - цикл по элементам массива
-int(num * num_buckets) - преобразование в целое число (вычисление индекса корзины)
-buckets[bucket_index].append(num) - добавление элемента в список-корзину
-sorted(bucket) - встроенная функция сортировки
-sorted_arr.extend() - расширение списка элементами другой последовательности

Сложность: O(n²) в худшем
Обоснование: Распределение по корзинам O(n), сортировка корзин O(Σm_i log m_i), где m_i - размер i-й корзины

Исходный массив: [0.42, 0.32, 0.67, 0.89, 0.11, 0.22]
Отсортированный массив: [0.11, 0.22, 0.32, 0.42, 0.67, 0.89]

2) БЛИННАЯ СОРТИРОВКА (PANCAKE SORT)

Блинная сортировка (pancake sort) — это алгоритм сортировки, который использует операцию "переворота" элементов массива. Алгоритм аналогичен процессу переворачивания стопки блинов, где можно вставить лопатку в любое место стопки и перевернуть все блины выше лопатки.

Принцип работы:
- Находим индекс максимального элемента в неотсортированной части: max_idx = arr.index(max(arr[:size]))
- Если максимум не в конце:
  - Переворачием часть до максимума, чтобы переместить его в начало: flip(max_idx)
  - Переворачием всю неотсортированную часть, чтобы переместить максимум в конец: flip(size - 1)
- Уменьшаем размер неотсортированной части и повторяем процесс

Использованные операторы и функции:
- def flip(subarray_end): - объявление вложенной функции переворота
- while start < subarray_end: - цикл с условием для переворота элементов
- arr[start], arr[subarray_end] = arr[subarray_end], arr[start] - множественное присваивание (обмен элементов)
- start += 1 - инкремент переменной
- subarray_end -= 1 - декремент переменной
- for size in range(n, 1, -1): - цикл с обратным отсчетом размера неотсортированной части
- arr.index(max(arr[:size])) - поиск индекса максимального элемента в срезе
- max(arr[:size]) - нахождение максимального значения в срезе массива
- arr[:size] - срез массива (неотсортированная часть)

Сложность: O(n²)  
Обоснование: В худшем случае требуется O(n) переворотов, каждый переворот занимает O(n) времени

Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]

3) СОРТИРОВКА БУСИНАМИ (BEAD SORT)

Сортировка бусинами (bead sort) — это алгоритм сортировки, также известный как гравитационная сортировка. 
Алгоритм имитирует падение бусин под действием гравитации на специальных стержнях, где каждая бусина представляет единицу значения элемента.

Принцип работы:
- Создается двумерный массив-абак размером n × max_val
- Расставляются "бусины" (единицы) согласно значениям исходного массива
- Бусины "падают" вниз - для каждого столбца вычисляется сумма и перераспределяются единицы
- Результирующие значения получаются как суммы строк

Использованные операторы и функции:
- not arr or min(arr) < 0 - проверка условий с логическими операторами
- min(arr), max(arr) - нахождение минимального и максимального значений
- [[0] * max_val for _ in range(len(arr))] - создание двумерного списка (абака)
- for i, num in enumerate(arr): - цикл с получением индекса и значения
- for j in range(num): - вложенный цикл по диапазону значения элемента
- beads[i][j] = 1 - присваивание элементам двумерного списка (расстановка бусин)
- sum(beads[i][j] for i in range(len(arr))) - генераторное выражение с суммированием (подсчет бусин в столбце)
- 1 if len(arr) - i <= sum_col else 0 - условное выражение (падение бусин)
- [sum(row) for row in beads] - списковое включение с суммированием (преобразование обратно в числа)

Сложность: O(n²)
Обоснование: Время зависит от максимального значения и количества элементов

Исходный массив: [4, 1, 6, 2, 3]
Отсортированный массив: [1, 2, 3, 4, 6]

4) ПОИСК СКАЧКАМИ (JUMP SEARCH)

Поиск скачками (jump search) — это алгоритм поиска в отсортированном массиве, который работает путем прыжков фиксированного 
размера с последующим линейным поиском в найденном блоке.

Принцип работы:
- Вычисляется размер прыжка: step = int(n ** 0.5)
- Выполняются прыжки пока не найден блок, где может находиться искомый элемент
- В найденном блоке выполняется линейный поиск

Использованные операторы и функции:
- n = len(arr) - получение длины массива
- int(n ** 0.5) - возведение в степень и преобразование в целое число (вычисление размера прыжка)
- while prev < n and arr[min(step, n) - 1] < target: - цикл с составным условием для прыжков
- min(step, n) - нахождение минимального значения (защита от выхода за границы)
- prev = step - присваивание (обновление предыдущей границы)
- step += int(n ** 0.5) - сложение с присваиванием (увеличение шага)
- for i in range(prev, min(step, n)): - цикл по диапазону для линейного поиска
- arr[i] == target - сравнение на равенство (проверка элемента)

Сложность: O(√n)  
Обоснование: Максимальное количество прыжков O(n/√n) = O(√n), линейный поиск в блоке O(√n)

Массив: [2, 5, 8, 12, 16, 23, 38, 45, 67, 73]
Элемент 23 найден на позиции: 5

5) ЭКСПОНЕНЦИАЛЬНЫЙ ПОИСК (EXPONENTIAL SEARCH)

Экспоненциальный поиск (exponential search) — это алгоритм поиска в отсортированном массиве, который находит диапазон,
где может находиться элемент, экспоненциально увеличивая границы, затем выполняет бинарный поиск в этом диапазоне.

Принцип работы:
- Проверяется первый элемент массива
- Границы поиска расширяются: i = 1, 2, 4, 8, ... пока не выйдем за пределы или не найдем диапазон
- В найденном диапазоне выполняется бинарный поиск

Использованные операторы и функции:
- arr[0] == target - проверка первого элемента массива
- while i < n and arr[i] <= target: - цикл с двумя условиями для экспоненциального расширения
- i *= 2 - умножение с присваиванием (удвоение границы)
- left = i // 2 - целочисленное деление (левая граница бинарного поиска)
- right = min(i, n - 1) - нахождение минимума (правая граница бинарного поиска)
- while left <= right: - цикл бинарного поиска
- mid = (left + right) // 2 - вычисление середины диапазона
- elif arr[mid] < target: - ветвление с условием сравнения
- left = mid + 1, right = mid - 1 - обновление границ поиска

Сложность: O(log n)  
Обоснование: Экспоненциальное расширение O(log n) + бинарный поиск O(log n)

Массив: [2, 5, 8, 12, 16, 23, 38, 45, 67, 73]
Элемент 45 найден на позиции: 7

6) ТЕРНАРНЫЙ ПОИСК (TERNARY SEARCH)

Тернарный поиск (ternary search) — это алгоритм поиска в отсортированном массиве, который рекурсивно делит массив на три части и определяет,
в какой из них продолжать поиск.
Принцип работы:
- Вычисляются две точки деления: mid1 = left + (right - left) // 3, mid2 = right - (right - left) // 3
-Проверка найден ли элемент:
  Если arr[mid1] == target → возвращается индекс mid1
  Если arr[mid2] == target → возвращается индекс mid2
-Выбор области для продолжения поиска:
  Если target < arr[mid1] → поиск в левой трети [left, mid1-1]
  Если target > arr[mid2] → поиск в правой трети [mid2+1, right]
  Иначе → поиск в средней трети [mid1+1, mid2-1]

Использованные операторы и функции:
- def ternary_recursive(left, right): - объявление рекурсивной функции
- if left > right: - базовый случай рекурсии (элемент не найден)
- mid1 = left + (right - left) // 3 - вычисление первой точки деления
- mid2 = right - (right - left) // 3 - вычисление второй точки деления
- if arr[mid1] == target:, if arr[mid2] == target: - проверки нахождения элемента в точках деления
- if target < arr[mid1]:, elif target > arr[mid2]:, else: - ветвление для выбора трети массива
- return ternary_recursive(left, mid1 - 1) - рекурсивный вызов для левой трети
- return ternary_recursive(mid2 + 1, right) - рекурсивный вызов для правой трети
- return ternary_recursive(mid1 + 1, mid2 - 1) - рекурсивный вызов для средней трети

Сложность: O(log₃n)  
Обоснование: На каждом шаге размер задачи уменьшается в 3 раза

Массив: [2, 5, 8, 12, 16, 23, 38, 45, 67, 73]
Элемент 16 найден на позиции: 4
