# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MquxLnXd0PEHxkKByyPbZ3GF7o8FY6CW
"""

# ===================== –£–°–¢–ê–ù–û–í–ö–ê –ë–ò–ë–õ–ò–û–¢–ï–ö =====================
!pip install -q dash dash-bootstrap-components jinja2==3.1.4 plotly tensorflow scikit-learn requests

import os
import threading
import time
import textwrap
import requests
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import classification_report, roc_auc_score, roc_curve

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers

import plotly.express as px
import plotly.graph_objs as go
import plotly.io as pio

from google.colab import output

import dash
from dash import dcc, html, Input, Output, State
import dash_bootstrap_components as dbc

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≤—ã–≤–æ–¥–∞ Plotly –¥–ª—è Colab
pio.renderers.default = "colab"

# ===================== 1. –ü–ê–†–ê–ú–ï–¢–†–´ –ü–†–û–ï–ö–¢–ê =====================

MAG_THRESHOLD = 6.0

params = {
    "test_size": 0.2,
    "random_state": 42,
    "hidden_layers": 3,
    "units_per_layer": [64, 64, 32],
    "activation": "relu",
    "dropout_rate": 0.2,
    "learning_rate": 1e-3,
    "batch_size": 256,
    "epochs": 20,
    "patience": 50,
}

# ===================== 2. –ó–ê–ì–†–£–ó–ö–ê –î–ê–¢–ê–°–ï–¢–ê =====================

def download_usgs_csv(filename="global_earthquakes_10yrs_M4.5_2025-12-10.csv"):
    """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –∏–ª–∏ —Å–æ–∑–¥–∞—ë—Ç –¥–∞—Ç–∞—Å–µ—Ç"""
    if os.path.exists(filename):
        print(f"‚úÖ –§–∞–π–ª {filename} —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
        return filename

    print("üì• –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∑–µ–º–ª–µ—Ç—Ä—è—Å–µ–Ω–∏–π...")
    try:
        url = "https://www.kaggle.com/datasets/kanchana1990/global-earthquakes-2015-2025-10-years-of-data"
        r = requests.get(url, timeout=10)
        r.raise_for_status()
        with open(filename, "wb") as f:
            f.write(r.content)
        print(f"‚úÖ –î–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –≤ {filename}")
    except Exception as e:
        print(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å: {e}")
        print("üìä –°–æ–∑–¥–∞—ë–º —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–π –¥–∞—Ç–∞—Å–µ—Ç...")
        create_dummy_csv(filename)

    return filename

def create_dummy_csv(filename):
    """–°–æ–∑–¥–∞—ë—Ç —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–π –¥–∞—Ç–∞—Å–µ—Ç"""
    np.random.seed(42)
    n_samples = 2000

    data = {
        'latitude': np.random.uniform(-90, 90, n_samples),
        'longitude': np.random.uniform(-180, 180, n_samples),
        'depth': np.random.uniform(0, 700, n_samples),
        'mag': np.random.uniform(4.5, 8.0, n_samples),
        'gap': np.random.uniform(0, 360, n_samples),
        'dmin': np.random.uniform(0, 10, n_samples),
        'rms': np.random.uniform(0, 1, n_samples),
        'horizontalError': np.random.uniform(0, 50, n_samples),
        'depthError': np.random.uniform(0, 100, n_samples),
        'magError': np.random.uniform(0, 0.5, n_samples),
    }

    df = pd.DataFrame(data)
    df.to_csv(filename, index=False)
    print(f"‚úÖ –°–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–π –¥–∞—Ç–∞—Å–µ—Ç —Å–æ–∑–¥–∞–Ω: {filename}")

csv_path = download_usgs_csv()

# ===================== 3. –ü–†–ï–î–û–ë–†–ê–ë–û–¢–ö–ê –î–ê–ù–ù–´–• =====================

def load_and_preprocess(csv_path, mag_threshold=MAG_THRESHOLD):
    """–ó–∞–≥—Ä—É–∂–∞–µ—Ç CSV –∏ –≥–æ—Ç–æ–≤–∏—Ç –¥–∞–Ω–Ω—ã–µ"""
    df = pd.read_csv(csv_path)
    print(f"üìä –ò—Å—Ö–æ–¥–Ω–∞—è —Ñ–æ—Ä–º–∞ –¥–∞—Ç–∞—Ñ—Ä–µ–π–º–∞: {df.shape}")

    candidate_features = [
        "latitude", "longitude", "depth", "mag",
        "gap", "dmin", "rms",
        "horizontalError", "depthError", "magError"
    ]
    features = [c for c in candidate_features if c in df.columns]
    print(f"‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏: {features}")

    df = df[features].dropna()
    print(f"‚úÖ –ü–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è NaN: {df.shape}")

    X = df[features].values.astype(float)
    y = (df["mag"].values >= mag_threshold).astype(int)

    return X, y, features

X, y, feature_names = load_and_preprocess(csv_path, MAG_THRESHOLD)

# ===================== 4. –†–ê–ó–ë–ò–ï–ù–ò–ï –ò –ú–ê–°–®–¢–ê–ë–ò–†–û–í–ê–ù–ò–ï =====================

X_train, X_test, y_train, y_test = train_test_split(
    X, y,
    test_size=params["test_size"],
    random_state=params["random_state"],
    stratify=y
)

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

print(f"‚úÖ –†–∞–∑–º–µ—Ä train: {X_train.shape}, test: {X_test.shape}")

# ===================== 5. –ü–û–°–¢–†–û–ï–ù–ò–ï –ú–û–î–ï–õ–ò =====================

def build_model(input_dim, cfg):
    model = keras.Sequential()
    model.add(layers.Input(shape=(input_dim,)))

    for i in range(cfg["hidden_layers"]):
        units = cfg["units_per_layer"][i]
        model.add(layers.Dense(units, activation=cfg["activation"]))
        if cfg["dropout_rate"] > 0:
            model.add(layers.Dropout(cfg["dropout_rate"]))

    model.add(layers.Dense(1, activation="sigmoid"))

    optimizer = keras.optimizers.Adam(learning_rate=cfg["learning_rate"])
    model.compile(
        optimizer=optimizer,
        loss="binary_crossentropy",
        metrics=["accuracy"]
    )
    return model

model = build_model(X_train_scaled.shape[1], params)
print("\n" + "="*60)
print("üß† –ê–†–•–ò–¢–ï–ö–¢–£–†–ê –ú–û–î–ï–õ–ò")
print("="*60)
model.summary()

# ===================== 6. –û–ë–£–ß–ï–ù–ò–ï =====================

print("\n" + "="*60)
print("üöÄ –ó–ê–ü–£–°–ö –û–ë–£–ß–ï–ù–ò–Ø –ù–ê " + str(params["epochs"]) + " –≠–ü–û–•")
print("="*60 + "\n")

history = model.fit(
    X_train_scaled, y_train,
    validation_split=0.2,
    epochs=params["epochs"],
    batch_size=params["batch_size"],
    verbose=1
)

# ===================== 7. –û–¶–ï–ù–ö–ê –ö–ê–ß–ï–°–¢–í–ê =====================

print("\n" + "="*60)
print("üìä –û–¶–ï–ù–ö–ê –ö–ê–ß–ï–°–¢–í–ê –ù–ê –¢–ï–°–¢–û–í–û–ô –í–´–ë–û–†–ö–ï")
print("="*60)

y_pred_proba = model.predict(X_test_scaled, verbose=0).ravel()
y_pred = (y_pred_proba >= 0.5).astype(int)

test_loss, test_accuracy = model.evaluate(X_test_scaled, y_test, verbose=0)

print("\n" + "="*60)
print("‚úÖ –ú–ï–¢–†–ò–ö–ò –ù–ê –¢–ï–°–¢–û–í–û–ô –í–´–ë–û–†–ö–ï")
print("="*60)
print(f"üî¥ Test Loss: {test_loss:.4f}")
print(f"üü¢ Test Accuracy: {test_accuracy:.4f}")

try:
    auc = roc_auc_score(y_test, y_pred_proba)
    print(f"üîµ ROC-AUC: {auc:.4f}")
except Exception as e:
    print(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ—Å—á–∏—Ç–∞—Ç—å ROC-AUC: {e}")
    auc = 0.0

print("\n" + "="*60)
print("üìã –ö–õ–ê–°–°–ò–§–ò–ö–ê–¶–ò–û–ù–ù–´–ô –û–¢–ß–Å–¢")
print("="*60)
print(classification_report(y_test, y_pred))

# ===================== 8. –°–û–ó–î–ê–ù–ò–ï –ì–õ–ê–î–ö–ò–• –ì–†–ê–§–ò–ö–û–í =====================

def smooth_curve(values, weight=0.8):
    """–ü—Ä–∏–º–µ–Ω—è–µ—Ç —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ"""
    smoothed = [values[0]]
    for i in range(1, len(values)):
        smoothed.append(weight * smoothed[-1] + (1 - weight) * values[i])
    return smoothed

epochs_range = list(range(1, len(history.history['loss']) + 1))
train_loss = history.history['loss']
val_loss = history.history['val_loss']
train_accuracy = history.history['accuracy']
val_accuracy = history.history['val_accuracy']

train_loss_smooth = smooth_curve(train_loss, weight=0.85)
val_loss_smooth = smooth_curve(val_loss, weight=0.85)
train_accuracy_smooth = smooth_curve(train_accuracy, weight=0.85)
val_accuracy_smooth = smooth_curve(val_accuracy, weight=0.85)

print("\n" + "="*60)
print("üìà –°–û–ó–î–ê–ù–ò–ï –ì–†–ê–§–ò–ö–û–í")
print("="*60)

# ===================== –ì–†–ê–§–ò–ö 1: –¢–û–ß–ù–û–°–¢–¨ =====================
print("\nüìä –ì—Ä–∞—Ñ–∏–∫ 1: –¢–æ—á–Ω–æ—Å—Ç—å –æ–±—É—á–µ–Ω–∏—è –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è")

fig_accuracy = go.Figure()

fig_accuracy.add_trace(go.Scatter(
    x=epochs_range,
    y=train_accuracy_smooth,
    mode='lines',
    name='–û–±—É—á–∞—é—â–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å',
    line=dict(color='#2196F3', width=3),
    hovertemplate='<b>–≠–ø–æ—Ö–∞ %{x}</b><br>–¢–æ—á–Ω–æ—Å—Ç—å –æ–±—É—á–µ–Ω–∏—è: %{y:.4f}<extra></extra>'
))

fig_accuracy.add_trace(go.Scatter(
    x=epochs_range,
    y=val_accuracy_smooth,
    mode='lines',
    name='–í–∞–ª–∏–¥–∞—Ü–∏–æ–Ω–Ω–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å',
    line=dict(color='#FF9800', width=3),
    hovertemplate='<b>–≠–ø–æ—Ö–∞ %{x}</b><br>–í–∞–ª–∏–¥–∞—Ü–∏–æ–Ω–Ω–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å: %{y:.4f}<extra></extra>'
))

fig_accuracy.update_layout(
    title='<b>–¢–æ—á–Ω–æ—Å—Ç—å –æ–±—É—á–µ–Ω–∏—è –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è</b>',
    xaxis_title='–≠–ø–æ—Ö–∞',
    yaxis_title='–¢–æ—á–Ω–æ—Å—Ç—å',
    hovermode='x unified',
    template='plotly_white',
    font=dict(size=12),
    height=600,
    plot_bgcolor='rgba(240, 240, 240, 0.5)',
    legend=dict(x=0.02, y=0.98)
)

fig_accuracy.show()
print("‚úÖ –ì—Ä–∞—Ñ–∏–∫ 1 –≤—ã–≤–µ–¥–µ–Ω")

# ===================== –ì–†–ê–§–ò–ö 2: –ü–û–¢–ï–†–ò =====================
print("\nüìä –ì—Ä–∞—Ñ–∏–∫ 2: –§—É–Ω–∫—Ü–∏—è –ø–æ—Ç–µ—Ä—å –æ–±—É—á–µ–Ω–∏—è –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è")

fig_loss = go.Figure()

fig_loss.add_trace(go.Scatter(
    x=epochs_range,
    y=train_loss_smooth,
    mode='lines',
    name='–û–±—É—á–∞—é—â–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø–æ—Ç–µ—Ä—å',
    line=dict(color='#4CAF50', width=3),
    hovertemplate='<b>–≠–ø–æ—Ö–∞ %{x}</b><br>–ü–æ—Ç–µ—Ä–∏ –æ–±—É—á–µ–Ω–∏—è: %{y:.4f}<extra></extra>'
))

fig_loss.add_trace(go.Scatter(
    x=epochs_range,
    y=val_loss_smooth,
    mode='lines',
    name='–í–∞–ª–∏–¥–∞—Ü–∏–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø–æ—Ç–µ—Ä—å',
    line=dict(color='#F44336', width=3),
    hovertemplate='<b>–≠–ø–æ—Ö–∞ %{x}</b><br>–í–∞–ª–∏–¥–∞—Ü–∏–æ–Ω–Ω—ã–µ –ø–æ—Ç–µ—Ä–∏: %{y:.4f}<extra></extra>'
))

fig_loss.update_layout(
    title='<b>–§—É–Ω–∫—Ü–∏—è –ø–æ—Ç–µ—Ä—å –æ–±—É—á–µ–Ω–∏—è –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è</b>',
    xaxis_title='–≠–ø–æ—Ö–∞',
    yaxis_title='–§—É–Ω–∫—Ü–∏—è –ø–æ—Ç–µ—Ä—å',
    hovermode='x unified',
    template='plotly_white',
    font=dict(size=12),
    height=600,
    plot_bgcolor='rgba(240, 240, 240, 0.5)',
    legend=dict(x=0.02, y=0.98)
)

fig_loss.show()
print("‚úÖ –ì—Ä–∞—Ñ–∏–∫ 2 –≤—ã–≤–µ–¥–µ–Ω")

# ===================== –ì–†–ê–§–ò–ö 3: ROC-–ö–†–ò–í–ê–Ø =====================
print("\nüìä –ì—Ä–∞—Ñ–∏–∫ 3: ROC-–∫—Ä–∏–≤–∞—è")

fpr, tpr, thresholds = roc_curve(y_test, y_pred_proba)

fig_roc = go.Figure()
fig_roc.add_trace(go.Scatter(
    x=fpr,
    y=tpr,
    mode='lines',
    name=f'ROC (AUC={auc:.3f})',
    line=dict(color='#2196F3', width=3),
    hovertemplate='<b>FPR: %{x:.4f}</b><br>TPR: %{y:.4f}<extra></extra>'
))

fig_roc.add_trace(go.Scatter(
    x=[0, 1],
    y=[0, 1],
    mode='lines',
    name='–°–ª—É—á–∞–π–Ω—ã–π –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä',
    line=dict(color='gray', width=2, dash='dash'),
))

fig_roc.update_layout(
    title='<b>ROC-–∫—Ä–∏–≤–∞—è –¥–ª—è –ø—Ä–æ–≥–Ω–æ–∑–∞ —Å–∏–ª—å–Ω—ã—Ö –∑–µ–º–ª–µ—Ç—Ä—è—Å–µ–Ω–∏–π</b>',
    xaxis_title='False Positive Rate',
    yaxis_title='True Positive Rate',
    template='plotly_white',
    font=dict(size=12),
    height=600,
    plot_bgcolor='rgba(240, 240, 240, 0.5)',
    legend=dict(x=0.6, y=0.4)
)

fig_roc.show()
print("‚úÖ –ì—Ä–∞—Ñ–∏–∫ 3 –≤—ã–≤–µ–¥–µ–Ω")

# ===================== –°–û–•–†–ê–ù–ï–ù–ò–ï –ú–û–î–ï–õ–ò =====================

model.save("earthquake_model.h5")
print("\n‚úÖ –ú–æ–¥–µ–ª—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ earthquake_model.h5")

# ===================== –§–£–ù–ö–¶–ò–ò –ü–†–ï–î–°–ö–ê–ó–ê–ù–ò–Ø =====================

def predict_probability(lat, lon, depth, mag,
                        gap=None, dmin=None, rms=None,
                        horizontalError=None, depthError=None, magError=None):
    """–§—É–Ω–∫—Ü–∏—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ —Å–∏–ª—å–Ω–æ–≥–æ –∑–µ–º–ª–µ—Ç—Ä—è—Å–µ–Ω–∏—è"""
    values = []
    for name in feature_names:
        if name == "latitude":
            values.append(lat)
        elif name == "longitude":
            values.append(lon)
        elif name == "depth":
            values.append(depth)
        elif name == "mag":
            values.append(mag)
        elif name == "gap":
            values.append(gap if gap is not None else 0.0)
        elif name == "dmin":
            values.append(dmin if dmin is not None else 0.0)
        elif name == "rms":
            values.append(rms if rms is not None else 0.0)
        elif name == "horizontalError":
            values.append(horizontalError if horizontalError is not None else 0.0)
        elif name == "depthError":
            values.append(depthError if depthError is not None else 0.0)
        elif name == "magError":
            values.append(magError if magError is not None else 0.0)

    arr = np.array(values, dtype=float).reshape(1, -1)
    arr_scaled = scaler.transform(arr)
    proba = model.predict(arr_scaled, verbose=0).ravel()[0]
    return float(proba)

print("\n" + "="*60)
print("üîÆ –ü–†–ò–ú–ï–†–´ –ü–†–ï–î–°–ö–ê–ó–ê–ù–ò–ô")
print("="*60)

examples = [
    (35.0, 140.0, 30.0, 5.5, "–°–ª–∞–±–æ–µ –∑–µ–º–ª–µ—Ç—Ä—è—Å–µ–Ω–∏–µ –≤ –Ø–ø–æ–Ω–∏–∏"),
    (40.0, 120.0, 25.0, 6.5, "–°–∏–ª—å–Ω–æ–µ –∑–µ–º–ª–µ—Ç—Ä—è—Å–µ–Ω–∏–µ –≤ –ö–∏—Ç–∞–µ"),
    (-15.0, -75.0, 100.0, 7.2, "–û—á–µ–Ω—å —Å–∏–ª—å–Ω–æ–µ –≤ –Æ–∂–Ω–æ–π –ê–º–µ—Ä–∏–∫–µ"),
]

for lat, lon, depth, mag, desc in examples:
    proba = predict_probability(lat=lat, lon=lon, depth=depth, mag=mag)
    status = "üî¥ –°–ò–õ–¨–ù–û–ï" if proba > 0.5 else "üü¢ –°–õ–ê–ë–û–ï"
    print(f"{status}: {desc}")
    print(f"   ‚Üí –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å: {proba:.4f}")

# ===================== –°–û–ó–î–ê–ù–ò–ï DASH-–ü–†–ò–õ–û–ñ–ï–ù–ò–Ø =====================

external_stylesheets = [dbc.themes.BOOTSTRAP]
app = dash.Dash(__name__, external_stylesheets=external_stylesheets)
server = app.server

df_full = pd.read_csv(csv_path)
if "mag" in df_full.columns:
    df_plot = df_full.dropna(subset=["latitude", "longitude", "mag"]).copy()
    df_plot["is_strong"] = df_plot["mag"] >= MAG_THRESHOLD
else:
    df_plot = pd.DataFrame(columns=["latitude", "longitude", "mag", "is_strong"])

def make_map_figure():
    if df_plot.empty:
        return go.Figure()
    fig = px.scatter_geo(
        df_plot.head(500),
        lat="latitude",
        lon="longitude",
        color="is_strong",
        hover_name="mag",
        projection="natural earth",
        title="üó∫Ô∏è –ö–∞—Ä—Ç–∞ –∑–µ–º–ª–µ—Ç—Ä—è—Å–µ–Ω–∏–π"
    )
    return fig

def make_mag_hist():
    if df_plot.empty:
        return go.Figure()
    fig = px.histogram(
        df_plot,
        x="mag",
        nbins=50,
        title="üìä –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –º–∞–≥–Ω–∏—Ç—É–¥",
    )
    return fig

project_explanation = f"""
## üåç –ù–µ–π—Ä–æ—Å–µ—Ç–µ–≤–∞—è –º–æ–¥–µ–ª—å –ø—Ä–æ–≥–Ω–æ–∑–∞ –∑–µ–º–ª–µ—Ç—Ä—è—Å–µ–Ω–∏–π

### üìä –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–±—É—á–µ–Ω–∏—è:
- **–≠–ø–æ—Ö–∏**: {params['epochs']}
- **Batch Size**: {params['batch_size']}
- **Learning Rate**: {params['learning_rate']}
- **–°–∫—Ä—ã—Ç—ã–µ —Å–ª–æ–∏**: {params['hidden_layers']}

### ‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–∞ —Ç–µ—Å—Ç–æ–≤–æ–π –≤—ã–±–æ—Ä–∫–µ:
- **Test Loss**: {test_loss:.4f} üî¥
- **Test Accuracy**: {test_accuracy:.4f} üü¢
- **ROC-AUC**: {auc:.4f} üîµ
"""

app.layout = dbc.Container(
    [
        html.H1("üåç –°–∏—Å—Ç–µ–º–∞ –ø—Ä–æ–≥–Ω–æ–∑–∞ –∑–µ–º–ª–µ—Ç—Ä—è—Å–µ–Ω–∏–π", className="mt-5 mb-4"),
        html.Hr(),

        dbc.Row([
            dbc.Col([
                dcc.Markdown(project_explanation)
            ], md=12)
        ], className="mb-4"),

        html.Hr(),

        html.H3("üìä –ö–ª—é—á–µ–≤—ã–µ –º–µ—Ç—Ä–∏–∫–∏", className="mt-4 mb-3"),
        dbc.Row([
            dbc.Col([
                html.Div([
                    html.H5("üî¥ Test Loss", style={"color": "#F44336"}),
                    html.Div(f"{test_loss:.4f}", style={"fontSize": "32px", "fontWeight": "bold", "color": "#F44336"})
                ], style={"padding": "20px", "border": "2px solid #F44336", "borderRadius": "8px", "textAlign": "center", "backgroundColor": "rgba(244, 67, 54, 0.1)"})
            ], md=3),
            dbc.Col([
                html.Div([
                    html.H5("üü¢ Test Accuracy", style={"color": "#4CAF50"}),
                    html.Div(f"{test_accuracy:.4f}", style={"fontSize": "32px", "fontWeight": "bold", "color": "#4CAF50"})
                ], style={"padding": "20px", "border": "2px solid #4CAF50", "borderRadius": "8px", "textAlign": "center", "backgroundColor": "rgba(76, 175, 80, 0.1)"})
            ], md=3),
            dbc.Col([
                html.Div([
                    html.H5("üîµ ROC-AUC", style={"color": "#2196F3"}),
                    html.Div(f"{auc:.4f}", style={"fontSize": "32px", "fontWeight": "bold", "color": "#2196F3"})
                ], style={"padding": "20px", "border": "2px solid #2196F3", "borderRadius": "8px", "textAlign": "center", "backgroundColor": "rgba(33, 150, 243, 0.1)"})
            ], md=3),
            dbc.Col([
                html.Div([
                    html.H5("üìà –≠–ø–æ—Ö–∏", style={"color": "#FF9800"}),
                    html.Div(f"{len(epochs_range)}/{params['epochs']}", style={"fontSize": "32px", "fontWeight": "bold", "color": "#FF9800"})
                ], style={"padding": "20px", "border": "2px solid #FF9800", "borderRadius": "8px", "textAlign": "center", "backgroundColor": "rgba(255, 152, 0, 0.1)"})
            ], md=3),
        ], className="mb-4"),

        html.Hr(),

        html.H3("üìà –ì—Ä–∞—Ñ–∏–∫–∏ –æ–±—É—á–µ–Ω–∏—è", className="mt-4 mb-3"),
        dbc.Row([
            dbc.Col([dcc.Graph(figure=fig_accuracy)], md=6),
            dbc.Col([dcc.Graph(figure=fig_loss)], md=6),
        ], className="mb-4"),

        dbc.Row([
            dbc.Col([dcc.Graph(figure=fig_roc)], md=6),
            dbc.Col([dcc.Graph(figure=make_mag_hist())], md=6),
        ], className="mb-4"),

        dbc.Row([
            dbc.Col([dcc.Graph(figure=make_map_figure())], md=12),
        ], className="mb-4"),

        html.Hr(),

        html.H3("üîÆ –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –ø—Ä–æ–≥–Ω–æ–∑", className="mt-4 mb-3"),
        dbc.Row([
            dbc.Col([
                dbc.Label("üìç –®–∏—Ä–æ—Ç–∞", className="fw-bold"),
                dbc.Input(id="inp-lat", type="number", value=35.0),
                dbc.Label("üìç –î–æ–ª–≥–æ—Ç–∞", className="fw-bold mt-3"),
                dbc.Input(id="inp-lon", type="number", value=140.0),
                dbc.Label("‚¨áÔ∏è –ì–ª—É–±–∏–Ω–∞ (–∫–º)", className="fw-bold mt-3"),
                dbc.Input(id="inp-depth", type="number", value=30.0),
                dbc.Label("üìä –ú–∞–≥–Ω–∏—Ç—É–¥–∞", className="fw-bold mt-3"),
                dbc.Input(id="inp-mag", type="number", value=5.5),
            ], md=3),
            dbc.Col([
                dbc.Label("‚öôÔ∏è Gap (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)", className="fw-bold"),
                dbc.Input(id="inp-gap", type="number", value=0.0),
                dbc.Label("üìè dmin (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)", className="fw-bold mt-3"),
                dbc.Input(id="inp-dmin", type="number", value=0.0),
                dbc.Label("‚è±Ô∏è rms (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)", className="fw-bold mt-3"),
                dbc.Input(id="inp-rms", type="number", value=0.0),
            ], md=3),
            dbc.Col([
                dbc.Label("üìä horizontalError (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)", className="fw-bold"),
                dbc.Input(id="inp-herr", type="number", value=0.0),
                dbc.Label("üìä depthError (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)", className="fw-bold mt-3"),
                dbc.Input(id="inp-derr", type="number", value=0.0),
                dbc.Label("üìä magError (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)", className="fw-bold mt-3"),
                dbc.Input(id="inp-merr", type="number", value=0.0),
            ], md=3),
            dbc.Col([
                html.Div([
                    dbc.Button("üîç –†–∞—Å—Å—á–∏—Ç–∞—Ç—å", id="btn-predict", color="primary", size="lg", className="w-100 mt-4"),
                    html.Div(id="pred-output", style={"fontSize": "16px", "fontWeight": "bold", "color": "darkblue", "marginTop": "20px", "padding": "15px", "backgroundColor": "#E3F2FD", "borderRadius": "8px", "border": "2px solid #2196F3"})
                ])
            ], md=3),
        ], className="mb-4"),

    ],
    fluid=True,
    className="p-4",
    style={"backgroundColor": "#F5F5F5", "minHeight": "100vh"}
)

@app.callback(
    Output("pred-output", "children"),
    Input("btn-predict", "n_clicks"),
    State("inp-lat", "value"),
    State("inp-lon", "value"),
    State("inp-depth", "value"),
    State("inp-mag", "value"),
    State("inp-gap", "value"),
    State("inp-dmin", "value"),
    State("inp-rms", "value"),
    State("inp-herr", "value"),
    State("inp-derr", "value"),
    State("inp-merr", "value"),
    prevent_initial_call=True
)
def update_prediction(n_clicks, lat, lon, depth, mag, gap, dmin, rms, herr, derr, merr):
    proba = predict_probability(
        lat=lat or 0.0,
        lon=lon or 0.0,
        depth=depth or 0.0,
        mag=mag or 0.0,
        gap=gap or 0.0,
        dmin=dmin or 0.0,
        rms=rms or 0.0,
        horizontalError=herr or 0.0,
        depthError=derr or 0.0,
        magError=merr or 0.0
    )
    status = "üî¥ –°–ò–õ–¨–ù–û–ï –ó–ï–ú–õ–ï–¢–†–Ø–°–ï–ù–ò–ï!" if proba > 0.5 else "üü¢ –°–ª–∞–±–æ–µ –∑–µ–º–ª–µ—Ç—Ä—è—Å–µ–Ω–∏–µ"
    return f"{status}\n–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å: {proba:.4f} ({proba*100:.2f}%)"