1. **Сортировка выбором (Selection Sort)**  
   Алгоритм последовательно находит минимальный (или максимальный) элемент в неотсортированной части массива и перемещает его в начало (или конец). Процесс повторяется до полного упорядочивания массива.  

   **Принцип работы:**  
   - Внешний цикл `for (int i = 0; i < n - 1; i++)` проходит по массиву, выбирая позицию для следующего минимального элемента.  
   - Внутренний цикл `for (int j = i + 1; j < n; j++)` находит минимальный элемент в неотсортированной части.  
   - Функция `swap(array, i, minIndex)` меняет местами текущий элемент и найденный минимум.  

   **Сложность:** O(n²)  
   **Обоснование:** Два вложенных цикла выполняются за n * n операций, где n — размер массива.
   Исходный массив: 64 25 12 22 11 
   Отсортированный массив: 11 12 22 25 64

---

2. **Сортировка пузырьком (Bubble Sort)**  
   Алгоритм многократно проходит по массиву, сравнивая соседние элементы и меняя их местами при нарушении порядка. Процесс повторяется до полной сортировки.  

   **Принцип работы:**  
   - Основной цикл `for (int i = 0; i < n - 1; i++)` обеспечивает повторение проходов.  
   - Внутренний цикл `for (int j = 0; j < n - i - 1; j++)` сравнивает и обменивает соседние элементы.  
   - После каждого прохода наибольший элемент "всплывает" в конец массива.  

   **Сложность:** O(n²)  
   **Обоснование:** Два вложенных цикла приводят к квадратичному количеству операций. 
   Исходный массив: 64 34 25 12 22 11 90 
   Отсортированный массив: 11 12 22 25 34 64 90

---

3. **Сортировка вставками (Insertion Sort)**  
   Алгоритм строит отсортированную часть массива, вставляя каждый новый элемент в правильную позицию среди уже упорядоченных.  

   **Принцип работы:**  
   - Начинается с первого элемента, который считается отсортированной частью.  
   - Для каждого следующего элемента он сравнивается с предыдущими и вставляется на нужную позицию.  
   - Используется цикл `while` или вложенный `for` для сдвига элементов и вставки.  

   **Сложность:** O(n²)  
   **Обоснование:** В худшем случае каждый элемент сравнивается со всеми предыдущими. 
   Исходный массив:
   38 27 43 3 9 82 10 
   Отсортированный массив:
   3 9 10 27 38 43 82 

---

4. **Сортировка слиянием (Merge Sort)**  
   Алгоритм разделяет массив на две половины, рекурсивно сортирует их, а затем объединяет в упорядоченную последовательность.  

   **Принцип работы:**  
   - Рекурсивное деление массива до подмассивов размером 1.  
   - Функция `merge` объединяет два отсортированных подмассива в один.  
   - Процесс повторяется до полного слияния всего массива.  

   **Сложность:** O(n log n)  
   **Обоснование:** Массив делится пополам на log n уровней, каждый уровень требует O(n) операций. 
   Исходный массив:
   38 27 43 3 9 82 10 
   Отсортированный массив:
   3 9 10 27 38 43 82

---

5. **Сортировка Шелла (Shell Sort)**  
   Улучшенная версия сортировки вставками, где элементы сравниваются на определённом расстоянии (gap).  

   **Принцип работы:**  
   - Массив разбивается на группы с шагом `gap`, каждая группа сортируется вставками.  
   - Шаг `gap` постепенно уменьшается до 1, после чего выполняется финальная сортировка вставками.  

   **Сложность:** O(n log n) (зависит от выбора шагов)  
   **Обоснование:** Число итераций зависит от последовательности шагов, в среднем — O(n log n). 
   Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]

---

6. **Быстрая сортировка (Quick Sort)**  
   Алгоритм выбирает опорный элемент (pivot), разделяет массив на элементы меньше и больше pivot, и рекурсивно сортирует части.  

   **Принцип работы:**  
   - Функция `partition` перераспределяет элементы относительно pivot.  
   - Рекурсивные вызовы `quickSort` для левой и правой частей.  
   - Базовый случай — массив размером 0 или 1.  

   **Сложность:** O(n log n)  
   **Обоснование:** В среднем массив делится пополам на log n уровней, каждый уровень требует O(n) операций.
   Исходный массив: 10 7 8 9 1 5 
   Отсортированный массив: 1 5 7 8 9 10

---

7. **Пирамидальная сортировка (Heap Sort)**  
   Алгоритм строит бинарную кучу (max-heap), извлекает корневой элемент (максимум) и помещает его в конец массива.  

   **Принцип работы:**  
   - Построение max-heap из массива.  
   - Последовательное извлечение корня и перестройка кучи.  
   - Элементы перемещаются в конец, уменьшая размер кучи.  

   **Сложность:** O(n log n)  
   **Обоснование:** Построение кучи — O(n), извлечение n элементов с перестройкой — O(n log n). 
   Исходный массив: [12, 11, 13, 5, 6, 7]
   Отсортированный массив: [5, 6, 7, 11, 12, 13]

---

8. **Линейный поиск (Linear Search)**  
   Алгоритм последовательно проверяет каждый элемент массива до нахождения искомого значения.  

   **Принцип работы:**  
   - Цикл `for` проходит по всем элементам.  
   - Если элемент найден, возвращается его индекс, иначе — -1.  

   **Сложность:** O(n)  
   **Обоснование:** В худшем случае требуется проверить все n элементов.
   Элемент найден на индексе: 3

---

9. **Бинарный поиск (Binary Search)**  
   Алгоритм работает с отсортированным массивом, repeatedly деля диапазон поиска пополам.  

   **Принцип работы:**  
   - Вычисление среднего элемента и сравнение с искомым значением.  
   - Сужение диапазона (low, high) в зависимости от результата сравнения.  
   - Процесс повторяется до нахождения элемента или завершения диапазона.  

   **Сложность:** O(log n)  
   **Обоснование:** На каждом шаге диапазон уменьшается вдвое. 
   Элемент 11 найден на индексе 4

---

10. **Интерполяционный поиск (Interpolation Search)**  
    Улучшенный вариант бинарного поиска для равномерно распределённых данных. Оценивает позицию искомого элемента на основе его значения.  

    **Принцип работы:**  
    - Использует формулу для расчёта позиции: `pos = low + ((value - arr[low]) * (high - low)) / (arr[high] - arr[low])`.  
    - Сравнивает элемент на полученной позиции с искомым значением и сужает диапазон.  

    **Сложность:** O(log log n)  
    **Обоснование:** При равномерном распределении данных диапазон сужается экспоненциально. 
   Элемент 18 найден на индексе 4.

---

11. **Поиск Фибоначчи (Fibonacci Search)**  
    Алгоритм использует числа Фибоначчи для определения точек разделения массива.  

    **Принцип работы:**  
    - Нахождение чисел Фибоначчи, превышающих размер массива.  
    - Сравнение элемента в точке деления с искомым значением.  
    - Сужение диапазона поиска на основе сравнения.  

    **Сложность:** O(log n)  
    **Обоснование:** Количество итераций пропорционально log n.
   Элемент 85 найден на индексе 8
